Day 96 coding Statement : 

Akhil has many balls of white and black colors. One day, he was playing with them. During the play, he arranged the balls into two rows both consisting of N number of balls. These two rows of balls are given to you in the form of strings X, Y. Both these string consist of 'W' and 'B', where 'W' denotes a white colored ball and 'B' a black colored.

Other than these two rows of balls, Akhil has an infinite supply of extra balls of each color. he wants to create another row of N balls, Z in such a way that the sum of hamming distance between X and Z, and hamming distance between Y and Z is maximized.

Hamming Distance between two strings X and Y is defined as the number of positions where the color of balls in row X differs from the row Y ball at that position. e.g. hamming distance between "WBB", "BWB" is 2, as at position 1 and 2, corresponding colors in the two strings differ.

.

As there can be multiple such arrangements of row Z, Akhil wants you to find the lexicographically smallest arrangement which will maximize the above value.





from collections import defaultdict

def min_operations_to_color_tree(T, test_cases):
    results = []
    
    def dfs(node, parent, current_A, target_B, adj_list):
        nonlocal operations
        # If the current node's color doesn't match, we perform an operation
        if current_A[node] != target_B[node]:
            operations += 1
            # Propagate the change to its subtree
            current_A[node] = target_B[node]
        
        # Visit children
        for child in adj_list[node]:
            if child != parent:  # Avoid revisiting the parent
                dfs(child, node, current_A, target_B, adj_list)
    
    for case in test_cases:
        N, A, B, edges = case
        adj_list = defaultdict(list)
        
        # Build adjacency list
        for u, v in edges:
            adj_list[u].append(v)
            adj_list[v].append(u)
        
        # Initialize operations count
        operations = 0
        
        # Perform DFS starting from node 1 (rooted at 1)
        dfs(1, -1, A, B, adj_list)
        
        results.append(operations)
    
    return results

# Input Reading
T = int(input())
test_cases = []

for _ in range(T):
    N = int(input())
    A = list(map(int, input().split()))
    B = list(map(int, input().split()))
    edges = [tuple(map(int, input().split())) for _ in range(N - 1)]
    test_cases.append((N, [0] + A, [0] + B, edges))  # Adding 0 at index 0 for 1-based indexing

# Process
results = min_operations_to_color_tree(T, test_cases)

# Output
for res in results:
    print(res)
